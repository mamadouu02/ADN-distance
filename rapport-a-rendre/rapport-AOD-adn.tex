\documentclass[10pt,a4paper]{article}

\usepackage[utf8]{inputenc}
% \usepackage[T1]{fontenc}
\usepackage{enumerate}
\usepackage{amssymb}

%%%% POUR FAIRE TENIR SUR UNE PAGE RECTO-VERSO.....
\textwidth 18.5cm
\oddsidemargin -1.75cm
\evensidemargin -1.75cm
\textheight 28.0cm
\topmargin -3.0cm

%   \textwidth 18cm
   %\oddsidemargin -1.5cm
   %\evensidemargin -1.5cm
   %\textheight 26.0cm
   %\topmargin -2.0cm
 


\begin{document}

\thispagestyle{empty}

\noindent\centerline{\bf\large Questionnaire  TP AOD 2023-2024 à compléter et rendre sur teide  } \\
Binôme 
(NOM\textsubscript{1} Prénom\textsubscript{1} --
 NOM\textsubscript{2} Prénom\textsubscript{2})
\,: BOUDAHMANE Ahmed -- THIONGANE Mamadou

\section{Préambule (1 point)}
Le programme récursif avec mémoisation alloue une mémoire de taille $N.M$.
Il génère une erreur d'exécution sur le test 5 (ci-dessous). Pourquoi ? \\
Réponse: Les séquences étant très longues sur le test 5, la mémoire demandée par le programme récursif pour l'allocation d'une mémoire de taille $N \times M$ et pour la pile d'appels récursifs est trop importante.
\begin{verbatim}
distanceEdition-recmemo    GCA_024498555.1_ASM2449855v1_genomic.fna 77328790 20236404   \
                           GCF_000001735.4_TAIR10.1_genomic.fna 30808129 19944517 
\end{verbatim}

%%%%%%%%%%%%%%%%%%%
{\noindent\bf{Important}.} Dans toute la suite, on demande des programmes qui allouent un espace mémoire $O(N+M)$.

\section{Programme itératif en espace mémoire $O(N+M)$ (5 points)}
{\em Expliquer très brièvement (2 à 5 lignes max) le principe de votre code, la mémoire utilisée, le sens de parcours des tableaux.}

\medskip

À partir de $\phi(M,N)$, on calcule $\left( \phi(i,j) \right)_{0 \leqslant i \leqslant M, 0 \leqslant j \leqslant N}$ itérativement par lignes. Le sens de parcours s'effectue de droite à gauche en remontant par lignes. Les $\phi(i,j)$ sont stockés par lignes en utilisant un tableau de taille $N+1$.

\medskip

Analyse du coût théorique de ce  programme en fonction de $N$ et $M$  en notation $\Theta(...)$ 
\begin{enumerate}
  \item place mémoire allouée (ne pas compter les 2 séquences $X$ et $Y$ en mémoire via {\tt mmap}) : $\Theta(N)$
  \item travail (nombre d'opérations) : $\Theta(NM)$
  \item nombre de défauts de cache obligatoires (sur modèle CO, y compris sur $X$ et $Y$): $\Theta \left( \frac{NM}{L} \right)$, $\Theta \left( \frac{M}{L} \right)$, $\Theta \left( \frac{N}{L} \right)$
  \item nombre de défauts de cache si $Z \ll \min(N,M)$ : $\Theta \left( \frac{NM}{L} \right)$, $\Theta \left( \frac{M}{L} \right)$, $\Theta \left( \frac{NM}{L} \right)$
\end{enumerate}

%%%%%%%%%%%%%%%%%%%
\section{Programme cache aware  (3 points)}
{\em Expliquer très brièvement (2 à 5 lignes max) le principe de votre code, la mémoire utilisée, le sens de parcours des tableaux.}

\medskip

À partir de $\phi(M,N)$, on calcule $\left( \phi(i,j) \right)_{0 \leqslant i \leqslant M, 0 \leqslant j \leqslant N}$ itérativement par blocs de taille $K \times K$. Le sens de parcours s'effectue de droite à gauche en remontant par blocs, chaque bloc étant parcouru par lignes. Les $\phi(i,j)$ sont stockés par lignes en utilisant un tableau de taille $N+1$ et les $\phi(i,j)$ d'un bloc sont stockés par colonnes en utilisant un tableau de taille $K = \sqrt{Z}$.

\medskip

Analyse du coût théorique de ce programme en fonction de $N$ et $M$  en notation $\Theta(...)$ )
\begin{enumerate}
  \item place mémoire allouée (ne pas compter les 2 séquences $X$ et $Y$ en mémoire via {\tt mmap}) : $\Theta(N + \sqrt{Z})$
  \item travail (nombre d'opérations) : $\Theta(NM)$
  \item nombre de défauts de cache obligatoires (sur modèle CO, y compris sur $X$ et $Y$): $\Theta \left( \frac{NM}{L} \right)$, $\Theta \left( \frac{NM}{\sqrt{Z} L} \right)$, $\Theta \left( \frac{NM}{\sqrt{Z} L} \right)$
  \item nombre de défauts de cache si $Z \ll \min(N,M)$ : $\Theta \left( \frac{NM}{L} \right)$, $\Theta \left( \frac{NM}{\sqrt{Z} L} \right)$, $\Theta \left( \frac{NM}{\sqrt{Z} L} \right)$
\end{enumerate}

%%%%%%%%%%%%%%%%%%%
\section{Programme cache oblivious  (3 points)}
{\em Expliquer très brièvement (2 à 5 lignes max) le principe de votre code, la mémoire utilisée, le sens de parcours des tableaux.}

\medskip

À partir de $\phi(M,N)$, on calcule $\left( \phi(i,j) \right)_{0 \leqslant i \leqslant M, 0 \leqslant j \leqslant N}$ récursivement par blocs de taille $S \times N$, où $S$ est le seuil de récursivité choisi de sorte à ce que toutes les valeurs de $X$ tiennent en cache en un bloc. Le sens de parcours s'effectue en remontant par blocs, chaque bloc étant parcouru en remontant par colonnes, de droite à gauche. Les $\phi(i,j)$ sont stockés par lignes en utilisant un tableau de taille $N+1$ et les $\phi(i,j)$ d'un bloc sont stockés par colonnes en utilisant un tableau de taille $S$.

\medskip

Analyse du coût théorique de ce  programme en fonction de $N$ et $M$  en notation $\Theta(...)$ )
\begin{enumerate}
  \item place mémoire allouée (ne pas compter les 2 séquences $X$ et $Y$ en mémoire via {\tt mmap}) : $\Theta(N + S)$
  \item travail (nombre d'opérations) : $\Theta(NM)$
  \item nombre de défauts de cache obligatoires (sur modèle CO, y compris sur $X$ et $Y$): $\Theta \left( \frac{NM}{L} \right)$, $\Theta \left( \frac{M}{L} \right)$, $\Theta \left( \frac{MN}{SL} \right)$
  \item nombre de défauts de cache si $Z \ll \min(N,M)$ : $\Theta \left( \frac{NM}{L} \right)$, $\Theta \left( \frac{MN}{L} \right)$, $\Theta \left( \frac{NM}{SL} \right)$
\end{enumerate}

\section{Réglage du seuil d'arrêt récursif du programme cache oblivious  (1 point)} 
Comment faites-vous sur une machine donnée pour choisir ce seuil d'arrêt? Quelle valeur avez vous choisi pour les
PC de l'Ensimag? (2 à 3 lignes) 

%%%%%%%%%%%%%%%%%%%
\section{Expérimentation (7 points)}

Description de la machine d'expérimentation:  \\
Processeur: Intel Core™ i5-7500 CPU @ 3.40GHz × 4 --
Mémoire: 32.0 GiB --
Système: Dell Inc. Precision Tower 3420

\subsection{(3 points) Avec {\tt 
	valgrind --tool=cachegrind --D1=4096,4,64
}} 
\begin{verbatim}
     distanceEdition ba52_recent_omicron.fasta 153 N wuhan_hu_1.fasta 116 M 
\end{verbatim}
en prenant pour $N$ et $M$ les valeurs dans le tableau ci-dessous.


Les paramètres du cache LL de second niveau est : ...
{\em mettre ici les paramètres: soit ceux indiqués ligne 3
du fichier cachegrind.out.(pid) généré par valgrind: soit ceux par défaut,
soit ceux que vous avez spécifiés à la main
\footnote{par exemple:
{\tt valgrind --tool=cachegrind --D1=4096,4,64 --LL=65536,16,256  ... }
mais ce n'est pas demandé car cela allonge le temps de simulation. } 
 pour LL. }

{\em Le tableau ci-dessous est un exemple,  complété avec vos résultats et 
ensuite analysé.}
\\
{\footnotesize
\begin{tabular}{|r|r||r|r|r||r|r|r||r|r|r||r|r|r||}
\hline
 \multicolumn{2}{|c||}{ } 
& \multicolumn{3}{c||}{récursif mémo}
& \multicolumn{3}{c||}{itératif}
& \multicolumn{3}{c||}{cache aware}
& \multicolumn{3}{c||}{cache oblivious}
\\ \hline
N & M 
& \#Irefs & \#Drefs & \#D1miss % recursif memoisation
& \#Irefs & \#Drefs & \#D1miss % itératif
& \#Irefs & \#Drefs & \#D1miss % cache aware
& \#Irefs & \#Drefs & \#D1miss % cache oblivious
\\ \hline
\hline
1000 & 1000 
& 217,200,815 & 122,122,238 & 4,925,369  % recursif memoisation
& 103,321,402 & 42,541,770 & 148,791  % itératif
& 118,750,875 & 51,792,350 & 7,362  % cache aware
& 139,073,200 & 66,379,265 & 6,525  % cache oblivious
\\ \hline
2000 & 1000 
& 433,378,209 & 243,401,470 & 11,022,819  % recursif memoisation
& 206,058,363 & 85,001,754 & 292,606  % itératif
& 236,903,406 & 103,495,478 & 9,843  % cache aware
& 277,535,016 & 132,659,677 & 8,268  % cache oblivious
\\ \hline
4000 & 1000 
& 867,150,307 & 487,365,726 & 23,222,782  % recursif memoisation
& 411,233,568 & 169,921,634 & 580,249  % itératif
& 472,909,239 & 206,901,349 & 14,681  % cache aware
& 554,163,276 & 265,221,667 & 13,072  % cache oblivious
\\ \hline
2000 & 2000 
& 867,141,905 & 487,888,421 & 19,896,557  % recursif memoisation
& 412,481,161 & 169,899,591 & 574,302  % itératif
& 474,160,260 & 206,882,587 & 14,779  % cache aware
& 555,413,924 & 265,201,830 & 11,643  % cache oblivious
\\ \hline
4000 & 4000 
& 3,465,864,618 & 1,950,548,616 & 80,000,438  % recursif memoisation
& 1,648,944,597 & 679,272,871 & 2,262,913  % itératif
& 1,895,444,821 & 827,084,387 & 52,392  % cache aware
& 2,220,523,172 & 1,060,384,536 & 39,438  % cache oblivious
\\ \hline
6000 & 6000 
& 7,796,325,080 & 4,387,984,427 & 180,346,527  % recursif memoisation
& 3,709,599,857 & 1,528,189,672 & 5,076,466  % itératif
& 4,264,063,812 & 1,860,675,440 & 92,168  % cache aware
& 4,991,734,938 & 2,386,191,401 & 89,535  % cache oblivious
\\ \hline
8000 & 8000 
& 13,857,954,627 & 7,799,947,998 & 321,302,450  % recursif memoisation
& 6,594,444,508 & 2,716,649,992 & 9,019,928  % itératif
& 7,580,302,267 & 3,307,820,288 & 160,715  % cache aware
& 8,880,432,681 & 4,240,893,529 & 174,261 % cache oblivious
\\ \hline
\hline
\end{tabular}
}

\paragraph{Important: analyse expérimentale:} 
ces mesures expérimentales sont elles en accord avec les coûts analysés théoriquement (justifier)  ? 
Quel algorithme se comporte le mieux avec valgrind et 
les paramètres proposés, pourquoi ?


\subsection{(3 points) Sans valgrind, par exécution de la commande :}
{\tt \begin{tabular}{llll}
distanceEdition & GCA\_024498555.1\_ASM2449855v1\_genomic.fna & 77328790 & M \\
                & GCF\_000001735.4\_TAIR10.1\_genomic.fna     & 30808129 & N
\end{tabular}}

On mesure le temps écoulé, le temps CPU et l'énergie consommée avec : {\em  [présicer ici comment vous avez fait la mesure:
{\tt time} 
ou {\tt /usr/bin/time}
ou {\tt getimeofday}
ou {\tt getrusage}
% ou {\tt perfstart/perfstop\_and\_display}%
% \footnote{
%     cf {\tt /matieres/4MMAOD6/2023-10-TP-AOD-ADN-Docs-fournis/tp-ADN-distance/srcperf/0-LisezMoi}
% }
ou... \\
L'énergie consommée sur le processeur peut être estimée en regardant le compteur RAPL d'énergie (en microJoule)
pour chaque core avant et après l'exécution et en faisant la différence.
Le compteur du core $K$ est dans le fichier 
\verb+ /sys/class/powercap/intel-rapl/intel-rapl:K/energy_uj + .\\
Par exemple, pour le c{\oe}ur 0: 
\verb+ /sys/class/powercap/intel-rapl/intel-rapl:0/energy_uj +
% Les fonctions fournies 
% {\tt perfstart/perfstop\_and\_display} dans le répertoire
% {\tt /matieres/4MMAOD6/2022-10-TP-AOD-ADN-Docs-fournis/tp-ADN-distance/srcperf} 
% font ces mesures de temps cpu, ecoulé et énergie.
% }

Nota bene: pour avoir un résultat fiable/reproductible (si variailité), 
il est préférable de faire chaque mesure 5 fois et de reporter l'intervalle
de confiance [min, moyenne, max]. 

\begin{tabular}{|r|r||r|r|r||r|r|r||r|r|r||}
\hline
 \multicolumn{2}{|c||}{ } 
& \multicolumn{3}{c||}{itératif}
& \multicolumn{3}{c||}{cache aware}
& \multicolumn{3}{c||}{cache oblivious}
\\ \hline
N & M 
& temps   & temps & energie       % itératif
& temps   & temps & energie       % cache aware
& temps   & temps & energie       % cache oblivious
\\
& 
& cpu     & écoulé&               % itératif
& cpu     & écoulé&               % cache aware
& cpu     & écoulé&               % cache oblivious
\\ \hline
\hline
10000 & 10000 
& [, , ] & [, , ] & [, , ]  % itératif
& [, , ] & [, , ] & [, , ]  % cache aware
& [, , ] & [, , ] & [, , ]  % cache oblivious
\\ \hline
20000 & 20000 
& [, , ] & [, , ] & [, , ]  % itératif
& [, , ] & [, , ] & [, , ]  % cache aware
& [, , ] & [, , ] & [, , ]  % cache oblivious
\\ \hline
30000 & 30000 
& [, , ] & [, , ] & [, , ]  % itératif
& [, , ] & [, , ] & [, , ]  % cache aware
& [, , ] & [, , ] & [, , ]  % cache oblivious
\\ \hline
40000 & 40000 
& [, , ] & [, , ] & [, , ]  % itératif
& [, , ] & [, , ] & [, , ]  % cache aware
& [, , ] & [, , ] & [, , ]  % cache oblivious
\\ \hline
\hline
\end{tabular}
\paragraph{Important: analyse expérimentale:} 
ces mesures expérimentales sont elles en accord avec les coûts analysés théroiquement (justifier)  ? 
Quel algorithme se comporte le mieux avec valgrind et 
les paramètres proposés, pourquoi ?

\subsection{(1 point) Extrapolation: estimation de la durée et de l'énergie pour la commande :}
{\tt \begin{tabular}{llll}
distanceEdition & GCA\_024498555.1\_ASM2449855v1\_genomic.fna & 77328790 & 20236404  \\
                & GCF\_000001735.4\_TAIR10.1\_genomic.fna     & 30808129 & 19944517 
\end{tabular}
}

A partir des résultats précédents, le programme {\em préciser itératif/cache aware/ cache oblivious} est
le plus performant pour la commande ci dessus (test 5); les ressources pour l'exécution seraient environ:
{\em (préciser la méthode de calcul utilisée)} 
\begin{itemize}
\item Temps cpu (en s) : ...
\item Energie  (en kWh) : ... .
\end{itemize}
Question subsidiaire: comment feriez-vous pour avoir un programme s'exécutant en moins de 1 minute ? 
{\em donner le principe en moins d'une ligne, même 1 mot précis suffit! }


\end{document}
